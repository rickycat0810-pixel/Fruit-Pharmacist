<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>æ°´æœæ¥æ¥æ¨‚ - é—œå¡ç‰ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #gameWrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 500px; /* ä¿æŒæ¯”ä¾‹ */
    }
    #topBar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
    }
    #score {
      font-size: 18px;
      font-weight: bold;
      color: #fff;
    }
    #pauseBtn, #restartBtn {
      font-size: 16px;
      padding: 6px 12px;
    }
    #restartBtn {
      display: none;
    }
    #gameCanvas {
      width: 100%;
      aspect-ratio: 5 / 6; /* ä¿æŒç›´å¼æ¯”ä¾‹ */
      border: 2px solid #333;
      background: #000;
    }
  </style>
</head>
<body>
  <div id="gameWrapper">
    <div id="topBar">
      <div id="score">åˆ†æ•¸: 0</div>
      <button id="pauseBtn">æš«åœ</button>
      <button id="restartBtn">é‡æ–°é–‹å§‹</button>
    </div>
    <canvas id="gameCanvas" width="500" height="600"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const scoreDisplay = document.getElementById("score");
    const restartBtn = document.getElementById("restartBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    const bgImg = new Image(); bgImg.src = "è—¥å±€.png";
    const playerImg = new Image(); playerImg.src = "è§’è‰².png";
    const failImg = new Image(); failImg.src = "å¤±æ•—.png";
    const successImg = new Image(); successImg.src = "æˆåŠŸ.png";
	const bgm = new Audio("BGM.m4a"); bgm.loop = true; bgm.volume = 0.5; // éŸ³é‡å¯èª¿æ•´
 	

    function playSoundFrom(src, startTime){
      const sound = new Audio(src);
      sound.addEventListener("loadedmetadata", () => {
        if (Number.isFinite(sound.duration) && startTime < sound.duration && startTime >= 0) {
          sound.currentTime = startTime;
        } else {
          sound.currentTime = 0;
        }
        sound.play().catch(()=>{});
      });
    }

    let failRatio = 1;
    failImg.onload = () => { failRatio = failImg.width / failImg.height; };
    let successRatio = 1;
    successImg.onload = () => { successRatio = successImg.width / successImg.height; };

    const fruitImgs = {
      "ğŸ": { img: new Image(), score: 1 },
      "ğŸŒ": { img: new Image(), score: 2 },
      "ğŸŠ": { img: new Image(), score: 3 },
      "ğŸ“": { img: new Image(), score: 5 },
      "ğŸ‰": { img: new Image(), bad: true }
    };
    fruitImgs["ğŸ"].img.src = "apple.png";
    fruitImgs["ğŸŒ"].img.src = "banana.png";
    fruitImgs["ğŸŠ"].img.src = "orange.png";
    fruitImgs["ğŸ“"].img.src = "strawberry.png";
    fruitImgs["ğŸ‰"].img.src = "watermelon.png";

    const fruits = ["ğŸ","ğŸŒ","ğŸŠ","ğŸ“"];
    let player, items, score, gameOver, mouseX, spawnInterval;
    let level, fruitCount, speedMultiplier, watermelonChance;
    let paused = true;
    const catchRadius = 30;
    const maxLevel = 10;
    const fruitsPerLevel = 30;

    let floatingTexts = [];
    let facingRight = true;
    let showSuccess = false;
    let successTimer = 0;
    let confetti = [];
    let audioUnlocked = false;

    function initGame() {
      player = { x:canvas.width/2-60, y:canvas.height-canvas.height/4-20, width:canvas.height/4*0.75, height:canvas.height/4, fail:false };
      items = []; score=0; gameOver=false; level=1; fruitCount=0;
      speedMultiplier=1; watermelonChance=0.2;
      scoreDisplay.textContent="åˆ†æ•¸: 0 | ç¬¬ 1 é—œ | å‰©é¤˜æ°´æœ: " + fruitsPerLevel;
      restartBtn.style.display="none"; 
	  pauseBtn.style.display="inline-block"; // âœ… é‡æ–°é–‹å§‹æ™‚é¡¯ç¤ºæš«åœéµ
	  mouseX=player.x;
      clearInterval(spawnInterval);
      spawnInterval=setInterval(spawnItem,1000);
      paused=true; update();
      pauseBtn.textContent = "ç¹¼çºŒ";
	  bgm.pause(); 
	  bgm.currentTime = 0; // ä¸€é–‹å§‹æ˜¯æš«åœç‹€æ…‹ï¼Œä¸æ’­æ”¾ï¼Œç­‰ç©å®¶æŒ‰ã€Œç¹¼çºŒã€æ‰æ’­æ”¾
	  
    }

    // æ»‘é¼ æ§åˆ¶
    canvas.addEventListener("mousemove", e=>{
      const rect=canvas.getBoundingClientRect();
      mouseX=e.clientX-rect.left-player.width/2;
    });

    // æ‰‹æ©Ÿè§¸æ§æ§åˆ¶
    canvas.addEventListener("touchmove", e=>{
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const touchX = touch.clientX - rect.left;
  const center = canvas.width / 2;

  let targetX;

  if (touchX >= center) {
    // å³å´ï¼šæ‰‹æŒ‡å°æ‡‰è§’è‰²å·¦é‚Šç·£ â†’ å¾€å³æ¨
    targetX = touchX; // player.x = å·¦é‚Šç·£
  } else {
    // å·¦å´ï¼šæ‰‹æŒ‡å°æ‡‰è§’è‰²å³é‚Šç·£ â†’ å¾€å·¦æ¨
    targetX = touchX - player.width; // player.x = å³é‚Šç·£ - å¯¬åº¦
  }

  // é‚Šç•Œä¿è­·
  if (targetX < 0) targetX = 0;
  if (targetX > canvas.width - player.width) targetX = canvas.width - player.width;

  mouseX = targetX;
});





    // æš«åœæŒ‰éˆ•æ§åˆ¶
pauseBtn.addEventListener("click", ()=>{
  if(gameOver) return;
  paused = !paused;
  if(!paused) {
    update();
    pauseBtn.textContent = "æš«åœ";   // éŠæˆ²é€²è¡Œä¸­ â†’ é¡¯ç¤ºæš«åœ
	bgm.play(); // âœ… éŠæˆ²ç¹¼çºŒ â†’ æ’­æ”¾ BGM
  } else {
    pauseBtn.textContent = "ç¹¼çºŒ";   // éŠæˆ²æš«åœä¸­ â†’ é¡¯ç¤ºç¹¼çºŒ
	bgm.pause(); // âœ… éŠæˆ²æš«åœ â†’ åœæ­¢ BGM
  }
  if(!audioUnlocked){
    const unlock = new Audio();
    unlock.play().catch(()=>{});
    audioUnlocked = true;
  }
});


    function spawnItem(){
      if(gameOver||paused) return;
      if(fruitCount>=fruitsPerLevel) return;
      const isBad=Math.random()<watermelonChance;
      const fruitKey=isBad?"ğŸ‰":fruits[Math.floor(Math.random()*fruits.length)];
      if(!isBad) fruitCount++;
      items.push({x:Math.random()*(canvas.width-60),y:-60,key:fruitKey,bad:isBad});
      scoreDisplay.textContent="åˆ†æ•¸: "+score+" | ç¬¬ "+level+" é—œ | å‰©é¤˜æ°´æœ: " + (fruitsPerLevel - fruitCount);
    }

    function update(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);
      ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.fillRect(0,0,canvas.width,canvas.height);

      player.x+=(mouseX-player.x)*0.1;
      facingRight = mouseX > player.x;

      ctx.save();
      ctx.translate(player.x+player.width/2, player.y);
      if(facingRight){ ctx.scale(-1,1); }
      if(player.fail){
        const targetHeight = player.height * 4/5;
        const targetWidth = targetHeight * failRatio;
        const offsetY = player.height - targetHeight;
        const offsetX = (player.width - targetWidth) / 2;
        ctx.drawImage(failImg,-player.width/2+offsetX,offsetY,targetWidth,targetHeight);
      } else {
        ctx.drawImage(playerImg,-player.width/2,0,player.width,player.height);
      }
      ctx.restore();

      if(gameOver){
        ctx.fillStyle="#fff"; ctx.font="28px sans-serif"; ctx.textAlign="center";
        ctx.fillText("éŠæˆ²çµæŸ! æœ€çµ‚åˆ†æ•¸: "+score,canvas.width/2,canvas.height/2-20);
        ctx.fillText("å¤šåƒæ°´æœ, ä¸‰èŠè—¥å¸«è—¥å±€é—œå¿ƒæ‚¨",canvas.width/2,canvas.height/2+20);
        return;
      }

      if(paused){
        if(showSuccess && successTimer > 0){
          const targetHeight = canvas.height * 0.75; 
          const targetWidth = targetHeight * successRatio; 
          const centerX = canvas.width / 2; 
          const offsetX = centerX - targetWidth / 2; 
          const offsetY = canvas.height - targetHeight; 
          ctx.drawImage(successImg, offsetX, offsetY, targetWidth, targetHeight);

                    confetti.forEach(c=>{
            ctx.fillStyle = c.color;
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.size, 0, Math.PI*2);
            ctx.fill();
            c.y += c.speed;
            c.x += Math.sin(c.y/20)*2;
          });
          confetti = confetti.filter(c => c.y < canvas.height+20);

          successTimer--;
          if(successTimer <= 0){
            showSuccess = false;
          }
          requestAnimationFrame(update);
          return;
        }

        ctx.fillStyle="rgba(0,0,0,0.7)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle="#fff"; ctx.font="20px sans-serif"; ctx.textAlign="center";
        ctx.fillText("éŠæˆ²æš«åœ",canvas.width/2,canvas.height/2-60);
        ctx.fillText("è¦å‰‡ï¼š",canvas.width/2,canvas.height/2-30);
        ctx.fillText("æ¯é—œæ‰è½ 30 é¡†æ°´æœ (ä¸å«è¥¿ç“œ)",canvas.width/2,canvas.height/2);
        ctx.fillText("æ¼æ¥æ°´æœæœƒæ‰£åˆ†ï¼Œæœ€ä½ 0 åˆ†",canvas.width/2,canvas.height/2+30);
        ctx.fillText("æ¥åˆ°æ°´æœé¡¯ç¤ºåŠ åˆ†æ–‡å­—",canvas.width/2,canvas.height/2+60);
        ctx.fillText("é»æ“Šæš«åœæŒ‰éˆ•ç¹¼çºŒéŠæˆ²",canvas.width/2,canvas.height/2+90);
        return;
      }

      items.forEach(item=>{
        item.y+=Math.min(10*speedMultiplier,(4+score*0.05)*speedMultiplier);
        const fruitData=fruitImgs[item.key];
        ctx.drawImage(fruitData.img,item.x,item.y,60,60);
        const playerCenterX=player.x+player.width/2;
        const playerCenterY=player.y+player.height/2;
        const fruitCenterX=item.x+30;
        const fruitCenterY=item.y+30;
        const dx=playerCenterX-fruitCenterX, dy=playerCenterY-fruitCenterY;
        const distance=Math.sqrt(dx*dx+dy*dy);

        if(distance<catchRadius){
          if(item.bad){ 
            playSoundFrom("è¥¿ç“œç ¸åˆ°.m4a", 0.5);
            endGame(); 
          } else {
            score+=fruitData.score;
            playSoundFrom("åƒæ°´æœ.m4a", 0.9);
            showFloatingText("+"+fruitData.score,"lime",fruitCenterX,fruitCenterY);
            scoreDisplay.textContent="åˆ†æ•¸: "+score+" | ç¬¬ "+level+" é—œ | å‰©é¤˜æ°´æœ: " + (fruitsPerLevel - fruitCount);
          }
          items = items.filter(f => f !== item);
        }
      });

      // æ¼æ¥æ°´æœ â†’ æ‰£åˆ†
      items.forEach(item=>{ 
        if(!item.bad && item.y > canvas.height){ 
          let deduct = fruitImgs[item.key].score; 
          if(score - deduct < 0){ deduct = score; }
          score -= deduct; 
          showFloatingText("-"+deduct,"red",item.x+30,canvas.height-30); 
          scoreDisplay.textContent = "åˆ†æ•¸: " + score + " | ç¬¬ " + level + " é—œ | å‰©é¤˜æ°´æœ: " + (fruitsPerLevel - fruitCount);
          items = items.filter(f => f !== item);
        } 
      });

      items = items.filter(item => item.y < canvas.height + 50);

      // åˆ¤æ–·éé—œ
      if(fruitCount >= fruitsPerLevel && items.length === 0){
        if(level < maxLevel){
          level++;
          fruitCount = 0;
          speedMultiplier *= 1.1;
          watermelonChance *= 1.1;
          scoreDisplay.textContent = 
            "åˆ†æ•¸: " + score + " | ç¬¬ " + level + " é—œ | å‰©é¤˜æ°´æœ: " + fruitsPerLevel;
          paused = true;
		  pauseBtn.textContent = "ç¹¼çºŒ";
          bgm.pause(); // âœ… éé—œæš«åœ â†’ åœæ­¢ BGM
          
		  setTimeout(()=>{ 
		  playSoundFrom("é€šé—œ.m4a", 0.0); 
		  }, 200); // å»¶é² 0.2 ç§’å†æ’­æ”¾

          showSuccess = true;
          successTimer = 180; 
          confetti = [];
          for(let i=0;i<50;i++){
            confetti.push({
              x: Math.random()*canvas.width,
              y: Math.random()*-canvas.height/2,
              size: 5+Math.random()*5,
              speed: 2+Math.random()*3,
              color: `hsl(${Math.random()*360},100%,50%)`
            });
          }
        } else {
          endGame();
        }
      }

      // é¡¯ç¤ºæµ®å‹•åˆ†æ•¸æ–‡å­—
      floatingTexts.forEach(ft=>{
        ctx.globalAlpha = ft.alpha;
        ctx.fillStyle = ft.color;
        ctx.font = "30px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1.0;

        ft.y -= 1;
        ft.alpha -= 0.03;
      });
      floatingTexts = floatingTexts.filter(ft => ft.alpha > 0);

      requestAnimationFrame(update);
    }

    function showFloatingText(text,color,x,y){
      floatingTexts.push({
        text:text,
        color:color,
        x:x,
        y:y,
        alpha:1
      });
    }

    function endGame(){
      gameOver = true;
      player.fail = true;
      restartBtn.style.display = "block";
	  pauseBtn.style.display = "none"; // âœ… è¢«è¥¿ç“œæ‰“ä¸­æ™‚éš±è—æš«åœéµ
	  bgm.pause(); // âœ… éŠæˆ²çµæŸ â†’ åœæ­¢ BGM
    }

    restartBtn.addEventListener("click", initGame);

    initGame();
  </script>
</body>
</html>
